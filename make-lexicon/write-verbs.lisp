;;; Copyright (C) 2019  Sony Computer Science Laboratories Paris
;;;                     Remi van Trijp (www.remivantrijp.eu)
;;; 
;;;     This program is free software: you can redistribute it and/or modify
;;;     it under the terms of the GNU General Public License as published by
;;;     the Free Software Foundation, version 3 of the License.
;;; 
;;;     This program is distributed in the hope that it will be useful,
;;;     but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;     GNU General Public License for more details.
;;; 
;;;     You should have received a copy of the GNU General Public License
;;;     along with this program.  If not, see <https://www.gnu.org/licenses/>.
;;; ----------------------------------------------------------------------------

(in-package :beng)

(defun write-verb-lex-cxn (out lemma &optional verb-type meaning)
  "Function for writing the lexical construction for verbs."
  (unless (symbolp lemma)
    (setf lemma (first lemma)))
  (unless meaning
    (setf meaning lemma))
  (format out "~%(fusion-add-parent '~a-1 'Actor *fusion-hierarchy*)" lemma)
  (format out "~%(fusion-add-parent '~a-2 'Undergoer *fusion-hierarchy*)" lemma)
  (if (eql verb-type 'ergative)
    (format out "~%(fusion-add-parent '~a-2 'Emphasized-Role *fusion-hierarchy*)" lemma)
    (format out "~%(fusion-add-parent '~a-1 'Emphasized-Role *fusion-hierarchy*)" lemma))
  (format out "~&(fusion-add-parent '~a 'Verb *fusion-hierarchy*)" meaning)
  (format out "~%~%(def-fcg-cxn ~a-verb-lex" meaning)
  (format out "~%             ((?~a-unit" lemma)
  (format out "~%               (referent ?ref-ev)")
  (format out "~%               (args (?ev ?context))")
  (format out "~%               (parent ?parent)")
  (format out "~%               (arg-struct ((role ?x ~a-1)" lemma)
  (format out "~%                            (role ?y ~a-2)))" lemma)
  (format out "~%               (syn-cat (verb-form ?vf)")
  (format out "~%                        (finite ?fin)")
  (format out "~%                        (agreement ?agr)")
  (format out "~%                        (tam ?tam)))")
  (format out "~%              <-")
  (format out "~%              (?~a-unit" lemma)
  (format out "~%               (hash meaning ((frame-type event ~a ?ev ?x ?y ?ref-ev)))" meaning)
  (format out "~%               --")
  (format out "~%               (sem-frame ~a)))" meaning)
  (format out "~%            :attributes (:label (hashed-lex-id hashed-meaning) :meaning ~a :lex-id ~a :pos (~s)))" meaning meaning "VERB"))

(defun write-syncretic-zero-morph (out lemma string &optional meaning)
  "Function for writing the base form morph-cxn for a verb."
  (unless (symbolp lemma)
    (setf lemma (first lemma)))
  (unless meaning (setf meaning lemma))
  (format out "~%~%(def-fcg-cxn ~a" (make-symbol (format nil "~a-morph" string)))
  (format out "~%             ((?~a-unit" string)
  (format out "~%               (footprints (number morph)))")
  (format out "~%              <-")
  (format out "~%              (?~a-unit" string)
  (format out "~%               (footprints (not number morph))")
  (format out "~%               (syn-cat (tam (tense ?tense)")
  (format out "~%                             (aspect (perfect ?perf)")
  (format out "~%                                     (progressive -))")
  (format out "~%                             (modality ?m)))")
  (format out "~%               (sem-frame ~a)" meaning)
  (format out "~%               --")
  (format out "~%               (HASH form ((string ?~a-unit ~s)))))" string string)
  (format out "~%            :disable-automatic-footprints t")
  (format out "~%            :attributes (:label (hashed-lex-id hashed-string) :string ~s :lex-id ~a :pos (~s)))" string meaning "VERB"))

(defun write-beat-zero-morph (out lemma string &optional meaning)
  "Function for the verb beat."
  (unless (symbolp lemma) (setf lemma (first lemma)))
  (unless meaning (setf meaning lemma))
  (format out "~%~%(def-fcg-cxn ~a" (make-symbol (format nil "~a->~a-morph" lemma string)))
  (format out "~%             ((?~a" string)
  (format out "~%               (footprints (number morph)))")
  (format out "~%              <-")
  (format out "~%              (?~a" string)
  (format out "~%               (footprints (not number morph))")
  (format out "~%               (syn-cat (tam (tense ?tense)")
  (format out "~%                             (aspect (perfect -)")
  (format out "~%                                     (progressive -))")
  (format out "~%                             (modality ?m)))")
  (format out "~%               (sem-frame ~a)" meaning)
  (format out "~%               --")
  (format out "~%               (HASH form ((string ?~a ~s)))))" string string)
  (format out "~%            :disable-automatic-footprints t")
  (format out "~%            :attributes (:label (hashed-lex-id hashed-string) :string ~s :lex-id ~a :pos (~s)))" string meaning "VERB"))

(defun write-run-zero-morph (out lemma string &optional meaning)
  "Function for the verb run."
  (unless (symbolp lemma) (setf lemma (first lemma)))
  (Unless meaning (setf meaning lemma))
  (format out "~%~%(def-fcg-cxn ~a" (make-symbol (format nil "~a->~a-morph" lemma string)))
  (format out "~%             ((?~a-unit" string)
  (format out "~%               (footprints (number morph)))")
  (format out "~%              <-")
  (format out "~%              (?~a-unit" string)
  (format out "~%               (footprints (not number morph))")
  (format out "~%               (syn-cat (tam (tense ?tense)")
  (format out "~%                             (aspect (perfect ?perfect)")
  (format out "~%                                     (progressive -))")
  (format out "~%                             (modality ?m)))")
  (format out "~%               (sem-frame ~a)" meaning)
  (format out "~%               --")
  (format out "~%               (HASH form ((string ?~a-unit ~s)))))" string string)
  (format out "~%            :disable-automatic-footprints t")
  (format out "~%            :attributes (:label (hashed-lex-id hashed-string) :string ~s :lex-id ~a :pos (~s)))" string meaning "VERB"))

(defun write-verb-base-morph (out lemma string &optional meaning)
    "Function for writing the base form morph-cxn for a verb."
    (unless (symbolp lemma) (setf lemma (first lemma)))
    (unless meaning (setf meaning lemma))
    (format out "~%~%(def-fcg-cxn ~a" (make-symbol (format nil "~a->~a-morph" lemma string)))
    (format out "~%             ((?~a-unit" string)
    (format out "~%               (footprints (number morph)))")
    (format out "~%              <-")
    (format out "~%              (?~a-unit" string)
    (format out "~%               (footprints (not number morph))")
    (format out "~%               (syn-cat (verb-form base-form)")
    (format out "~%                        (tam (tense ?tense)")
    (format out "~%                             (aspect (perfect -)")
    (format out "~%                                     (progressive -))")
    (format out "~%                             (modality ?m)))")
    (format out "~%               (sem-frame ~a)" meaning)
    (format out "~%               --")
    (format out "~%               (HASH form ((string ?~a-unit ~s)))))" string string)
    (format out "~%            :disable-automatic-footprints t")
    (format out "~%            :attributes (:label (hashed-lex-id hashed-string) :string ~s :lex-id ~a :pos (~s)))" string meaning "VERB"))

(defun write-verb-3sg-morph (out lemma string &optional meaning)
  "Function for writing the base form morph-cxn for a verb."
  (unless (symbolp lemma) (setf lemma (first lemma)))
  (unless meaning (setf meaning lemma))
  (format out "~%~%(def-fcg-cxn ~a" (make-symbol (format nil "~a->~a-morph" lemma string)))
  (format out "~%             ((?~a-unit" string)
  (format out "~%               (footprints (number morph)))")
  (format out "~%              <-")
  (format out "~%              (?~a-unit" string)
  (format out "~%               (footprints (not number morph))")
  (format out "~%               (syn-cat (verb-form base-form)")
  (format out "~%                        (finite +)")    
  (format out "~%                        (agreement (- - + -))")
  (format out "~%                        (tam (tense present)")
  (format out "~%                             (aspect (perfect -)")
  (format out "~%                                     (progressive -))")
  (format out "~%                             (modality indicative)))")
  (format out "~%               (sem-frame ~a)" meaning)
  (format out "~%               --")
  (format out "~%               (HASH form ((string ?~a-unit ~s)))))" string string)
  (format out "~%            :disable-automatic-footprints t")
  (format out "~%            :attributes (:label (hashed-lex-id hashed-string) :string ~s :lex-id ~a :pos (~s)))" string meaning "VERB"))

(defun write-verb-ing-morph (out lemma string &optional meaning)
  "Function for writing the base form morph-cxn for a verb."
  (unless (symbolp lemma) (setf lemma (first lemma)))
  (unless meaning (setf meaning lemma))
  (format out "~%~%(def-fcg-cxn ~a" (make-symbol (format nil "~a->~a-morph" lemma string)))
  (format out "~%             ((?~a-unit" string)
  (format out "~%               (footprints (number morph)))")
  (format out "~%              <-")
  (format out "~%              (?~a-unit" string)
  (format out "~%               (footprints (not number morph))")
  (format out "~%               (syn-cat (verb-form ing-form)")
  (format out "~%                        (finite -)")
  (format out "~%                        (agreement ?agr)")
  (format out "~%                        (tam (tense ?tense)")
  (format out "~%                             (aspect (perfect ?p)")
  (format out "~%                                     (progressive +))")
  (format out "~%                             (modality ?m)))")
  (format out "~%               (sem-frame ~a)" lemma)
  (format out "~%               --")
  (format out "~%               (HASH form ((string ?~a-unit ~s)))))" string string)
  (format out "~%            :disable-automatic-footprints t")
  (format out "~%            :attributes (:label (hashed-lex-id hashed-string) :string ~s :lex-id ~a :pos (~s)))" string meaning "VERB"))

(defun write-verb-past-tense-form (out lemma string &optional meaning)
  "Function for a unique past tense form."
  (unless (symbolp lemma) (setf lemma (first lemma)))
  (unless meaning (setf meaning lemma))
  (format out "~%~%(def-fcg-cxn ~a" (make-symbol (format nil "~a->~a-morph" lemma string)))
  (format out "~%             ((?~a-unit" string)
  (format out "~%               (footprints (number morph)))")
  (format out "~%              <-")
  (format out "~%              (?~a-unit" string)
  (format out "~%               (footprints (not number morph))")
  (format out "~%               (syn-cat (verb-form participle)")
  (format out "~%                        (finite +)")
  (format out "~%                        (agreement ?agr)")
  (format out "~%                        (tam (tense past)")
  (format out "~%                             (aspect (perfect -)")
  (format out "~%                                     (progressive -))")
  (format out "~%                             (modality indicative)))")
  (format out "~%               (sem-frame ~a)" meaning)
  (format out "~%               --")
  (format out "~%               (HASH form ((string ?~a-unit ~s)))))" string string)
  (format out "~%            :disable-automatic-footprints t")
  (format out "~%            :attributes (:label (hashed-lex-id hashed-string) :string ~s :lex-id ~a :pos (~s)))" string meaning "VERB"))

(defun write-verb-past-participle-form (out lemma string &optional meaning)
  "Function for a unique past participle form."
  (unless (symbolp lemma) (setf lemma (first lemma)))
  (unless meaning (setf meaning lemma))
  (format out "~%~%(def-fcg-cxn ~a" (make-symbol (format nil "~a->~a-morph" lemma string)))
  (format out "~%             ((?~a-unit" string)
  (format out "~%               (footprints (number morph)))")
  (format out "~%              <-")
  (format out "~%              (?~a-unit" string)
  (format out "~%               (footprints (not number morph))")
  (format out "~%               (syn-cat (verb-form participle)")
  (format out "~%                        (finite -)")
  (format out "~%                        (agreement ?agr)")
  (format out "~%                        (tam (tense ?tense)")
  (format out "~%                             (aspect (perfect +)")
  (format out "~%                                     (progressive -))")
  (format out "~%                             (modality ?modality)))")
  (format out "~%               (sem-frame ~a)" meaning)
  (format out "~%               --")
  (format out "~%               (HASH form ((string ?~a-unit ~s)))))" string string)
  (format out "~%            :disable-automatic-footprints t")
  (format out "~%            :attributes (:label (hashed-lex-id hashed-string) :string ~s :lex-id ~a :pos (~s)))" string meaning "VERB"))

(defun write-verb-syncretic-participles-morph (out lemma string &optional meaning)
  "Function for writing the base form morph-cxn for a verb."
  (unless (symbolp lemma) (setf lemma (first lemma)))
  (unless meaning (setf meaning lemma))
  (format out "~%~%(def-fcg-cxn ~a" (make-symbol (format nil "~a->~a-morph" lemma string)))
  (format out "~%             ((?~a-unit" string)
  (format out "~%               (footprints (number morph)))")
  (format out "~%              <-")
  (format out "~%              (?~a-unit" string)
  (format out "~%               (footprints (not number morph))")
  (format out "~%               (syn-cat (verb-form participle)")
  (format out "~%                        (tam (tense ?tense)")
  (format out "~%                             (aspect ?aspect)")
  (format out "~%                             (modality ?m)))")
  (format out "~%               (sem-frame ~a)" meaning)
  (format out "~%               --")
  (format out "~%               (HASH form ((string ?~a-unit ~s)))))" string string)
  (format out "~%            :disable-automatic-footprints t")
  (format out "~%            :attributes (:label (hashed-lex-id hashed-string) :string ~s :lex-id ~a :pos (~s)))" string meaning "VERB"))

(defun write-verb-definition (verb &key verb-type (verb-class t))
  "Function for writing the definitions of verbs."
  (with-open-file (out (ensure-directories-exist
                        (beng-pathname :directory '("lexicon" "verbs")
                                       :name (downcase (symbol-name (cond ((eql 'quiz verb) 'kwiz)
                                                                          ((symbolp verb) verb)
                                                                          (t
                                                                           (first verb)))))
                                       :type "lisp"))
                       :direction :output :if-exists :supersede)
    (add-license-and-copyright-header out)
    (format out "~%~%(in-package :beng)")
    (multiple-value-bind (base-form 3sg-form ing-form past-tense-form past-participle-form)
        (conjugate-verb verb verb-class)
      ;; Write the lexical construction.
      (write-verb-lex-cxn out verb verb-type)
      ;; Write the 3SG morph construction.
      (write-verb-3sg-morph out verb 3sg-form)
      ;; Write the ING-form.
      (write-verb-ing-morph out verb ing-form)
      ;; Now handle the base-form and past participles.
      (cond (;; Base-form = Past Tense = Past Participle
             (and (string= base-form past-tense-form) (string= base-form past-participle-form))
             (write-syncretic-zero-morph out verb base-form))
            (;; Past-Tense = Past Participle (~ includes regular verbs)
             (string= past-tense-form past-participle-form)
             (write-verb-base-morph out verb base-form)
             (write-verb-syncretic-participles-morph out verb past-tense-form))
            (;; Base-form = Past tense form (e.g. beat, beat, beaten)
             (string= base-form past-tense-form)
             (write-beat-zero-morph out verb base-form)
             (write-verb-past-participle-form out verb past-participle-form))
            (;; Base-form = Past participle (e.g. run ran run)
             (string= base-form past-participle-form)
             (write-run-zero-morph out verb base-form)
             (write-verb-past-tense-form out verb past-tense-form))
            (t ;; Different base form and participles
               (write-verb-base-morph out verb base-form)
               (write-verb-past-tense-form out verb past-tense-form)
               (write-verb-past-participle-form out verb past-participle-form))))))

(defun correct-verbs ()
  (dolist (verb-class (append *irregular-verbs-by-class*
                              `((regular-verbs (accusative ,@*accusative-verbs*)
                                               (ergative ,@*ergative-verbs*)))))
    (let ((verb-type nil))
      (dolist (verb (apply #'append (rest verb-class)))
        (if (member verb '(accusative ergative))
          (setf verb-type verb)
          (when (cl-ppcre:scan ".+[aeou][y]$"
                               (downcase (symbol-name (if (listp verb) (first verb) verb))))
            (write-verb-definition verb :verb-type verb-type :verb-class (first verb-class))))))))
;; (correct-verbs)

(defun write-verbs ()
  "Creates Lisp files with the FCG definitions of all verbs except auxiliaries."
  (dolist (verb-class (append *irregular-verbs-by-class*
                              `((regular-verbs (accusative ,@*accusative-verbs*)
                                               (ergative ,@*ergative-verbs*)))))
    (let ((verb-type nil))
      (dolist (verb (apply #'append (rest verb-class)))
        (if (member verb '(accusative ergative))
          (setf verb-type verb)
          (write-verb-definition verb :verb-type verb-type :verb-class (first verb-class))))))
  (correct-verbs))
;; (write-verbs)